---
author: [Philip Olwoc, Hannah Brown, Rebekah Rudd, Gregory M. Kapfhammer]
title: 'Reducing Failure-Inducing Inputs'
date: '2024-12-04'
date-format: long
categories: [post, software engineering, fuzzing book]
description: <em>What are different methods of reducing failure-inducing inputs? And what are their benefits and drawbacks?</em>
toc: true
page-layout: full
---

## Overview

This article covers the [Reducing Failure-Inducing
Inputs](https://www.fuzzingbook.org/html/Reducer.html) chapter from [Fuzzing
Book](https://www.fuzzingbook.org/). This chapter builds on the concepts from
the [Fuzzing](https://www.fuzzingbook.org/html/Fuzzer.html) and [Fuzzing With
Grammars](https://www.fuzzingbook.org/html/Grammars.html) chapters. Let's get started and learn more about increasing the efficiency of fuzzed inputs and bug finding!

## Summary (hannah)

## Delta Debugging

Delta debugging is using fuzzing to find what fails and then taking the large input to reduce it to the part of the string that was failing. This will decrease the inputs and help the user know what is failing so that then they are able to find the bug more easily. The goal is to find failures so that we can then find out why the code failed and how to fix the issue.

"A reducer takes a failure-inducing input and reduces it to the minimum that still reproduces the failure." This chapter shows the Reducer class.

Manual reduction input has to do with manually testing ans iterating through the code in order to find the bug. Where as delta debugging automates this process of testing in order to find the failures. 

Delta debugging first tests the first half of the code to see if it fails. If it passes it will then test the second half of the string. If that also passes the delta debugger will iterate through different combinations of different quarters of the string. The size of the string that the delta debugger tests gets smaller and smaller until there are only one or two characters left. But this can be confusing so lets walk through an example. 

```python
dd_reducer = DeltaDebuggingReducer(mystery, log_test=True)
dd_reducer.reduce(failing_input)
```

```text
Round 1 (1/2):
Test #1 ' 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 97 FAIL
Test #2 '\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 49 PASS
Test #3 " 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69':" 48 PASS

Round 2 (1/4): 
Test #4 '50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 73 FAIL
Test #5 "50#7*8=$&&=$9!%6(4=&69':<7+1<2!4$>92+$1<(3%&5''>#" 49 PASS
Test #6 '50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+' 48 FAIL
Test #7 '\'<3+0-3.24#7=!&60)2/+";+' 24 PASS
Test #8 "50#7*8=$&&=$9!%6(4=&69':" 24 PASS

Round 3 (1/8):
Test #9 '9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+' 36 FAIL
Test #10 '9!%6(4=&69\':=!&60)2/+";+' 24 FAIL
Test #11 '=!&60)2/+";+' 12 PASS
Test #12 "9!%6(4=&69':" 12 PASS
Test #13 '=&69\':=!&60)2/+";+' 18 PASS
Test #14 '9!%6(4=!&60)2/+";+' 18 FAIL
Test #15 '9!%6(42/+";+' 12 PASS
Test #16 '9!%6(4=!&60)' 12 FAIL
Test #17 '=!&60)' 6 PASS
Test #18 '9!%6(4' 6 PASS
Test #19 '6(4=!&60)' 9 FAIL
Test #20 '6(460)' 6 FAIL
Test #21 '60)' 3 PASS
Test #22 '6(4' 3 PASS
Test #23 '(460)' 5 FAIL
Test #24 '460)' 4 PASS
Test #25 '(0)' 3 FAIL
Test #26 '0)' 2 PASS
Test #27 '(' 1 PASS
Test #28 '()' 2 FAIL
Test #29 ')' 1 PASS
'()'
```

### Benefits

First, one benefit of a delta debugger is that it "reduces the cognitive load of the programmer". It makes it so the test cases can address a problem specifically rather than a broad unaddressable problem. Second, it also makes the problem easier to communicate to others. And finally, it can make it more obvious to programmers if there are duplicates in a test case that are addressing the same problem.

**But is this effective?**

The best case for this is logarithmic or Big O(log2 n). While the worst case is Big O(n^2). This happens when the program runs and the last character fails. If the last character fails the program will then return an AssertionError. The goal is for the last character to pass so that it is clear the error resulted in the penultimate character.

![Big O(n) graph comparisons](big0n_graph.gif)

### Drawbacks
One issue is that with delta debugging is that it is prone to failure. This method is not always accurate. In addition, another issue is that it is not the most efficient method of determining the failing piece of code. Which leads us to the another method of iterating through the fuzzing produced string in order to find the piece of the string that is failing called Grammar Based Reduction. 

## Grammar Based Reduction (philip)

## Use Cases (hannah)
